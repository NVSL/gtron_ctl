#!/usr/bin/env python

import argparse
import sys
import subprocess
import os
import re
import json
import pipes
import shutil
import logging as log
import StringIO


class TermColors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def in_red(s):
    return TermColors.FAIL + s + TermColors.ENDC
def in_green(s):
    return TermColors.GREEN + s + TermColors.ENDC

class Repo:
    def __init__(self, json, count=0):
        self.url = json["url"]
        self.container_directory = os.path.normpath(json["directory"])
        self.repo_directory = re.search(".*/([\{\}\$\w\-]*)(/$)?", self.url).group(1)
        self.full_directory = os.path.normpath(os.path.join(self.container_directory,self.repo_directory))
        self.stored_order = json.get("order")
        if json.get("no_build") is not None:
            self.no_build = True if json.get("no_build").upper() is "TRUE" else False;
        else:
            self.no_build = False
            
        if self.stored_order is None:
            self.sort_by = count;
        else:
            self.sort_by = self.stored_order
            
    def to_json(self):
        r =  {"url": self.url,
              "directory": self.container_directory}
        if self.stored_order is not None:
            r["order"] = self.stored_order
        return r

    def expand_variables(self, workspace):
        self.url = workspace.eval_with_variables(self.url)
        self.container_directory = workspace.eval_with_variables(self.container_directory)
        self.repo_directory = workspace.eval_with_variables(self.repo_directory)
        self.full_directory = workspace.eval_with_variables(self.full_directory)
        
class WorkspaceConfig:
    def __init__(self,devel_root, config_file):
        json_data = json.load(open(config_file))
        self.config_file = config_file
        self.devel_root = devel_root
        self.variables = json_data["vars"]
        order = 500;
        
        self.repo_map = {}
        for r in json_data["repos"]:
            n = Repo(r, order);
            self.add_repo(n);
            order = order + 1

    def normalize_path(self, path):
        return os.path.normpath(os.path.realpath(path)).replace(self.devel_root+"/","")
            
    def repos(self):
        return sorted(self.repo_map.itervalues(), cmp=lambda x,y: cmp(x.sort_by, y.sort_by));

    def add_repo(self, r):
        log.info("Adding repo '{}' -> '{}'".format(r.full_directory, r.url))
        self.repo_map[r.full_directory] = r

    def remove_repo(self, r):
        del self.repo_map[r]

    def get_repo(self, directory):
        directory = self.normalize_path(directory)
        return self.repo_map.get(directory)
    
    def to_json(self):
        return {"vars" : self.variables,
                "repos" : [r.to_json() for r in self.repos()]}

    def expand_variables(self):
        for v in self.variables:
            self.variables[v] = self.eval_with_variables(self.variables[v])
        repos = self.repos();
        self.repo_map={};
        for r in repos:
            r.expand_variables(self)
            self.add_repo(r)
            
    def write_config_to_file(self, file):
        json.dump(self.to_json(),
                  file,
                  sort_keys=True,
                  indent=4,
                  separators=(',', ': '))        

    def dump(self):
        self.write_config_to_file(sys.stdout)
        
    def write_config(self):
        log.info("Writing out config file '{}'...".format(self.config_file))
        shutil.copyfile(self.config_file, self.config_file + ".bak")
        self.write_config_to_file(open(self.config_file, "w"))

    def eval_with_variables(self, s):
        from string import Template
        last = ""
        new = s
        while last != new:
            last = new;
            new = Template(last).safe_substitute(self.variables)
        return new


        
class Command:
    @classmethod
    def setup(cls, subparsers, name, help, description):
        subparser = subparsers.add_parser(name, help=help, description=description)
        subparser.set_defaults(func=cls.go)
        cls.add_args(subparser)
    @classmethod
    def add_args(cls, parser):
        pass

class ParseAndDispatch:
    def __init__(self, app_desc, subp_title, subp_desc):
        self.parser = argparse.ArgumentParser(description=app_desc)
        self.subparsers = self.parser.add_subparsers(title=subp_title,
                                                     description=subp_desc)
    def add_command(self, cmd):
        cmd.setup(self.subparsers, cmd.__name__, cmd.help, cmd.description)

    def parse_args(self, argv):
        return self.parser.parse_args(argv)


dry_run = False;

def do_cmd(s, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin):
    if dry_run is True:
        output = ""
        print s
    else:
        log.info("Executing: " + s);
        try:
            if stdout == "RETURN_VALUE":
                output = subprocess.check_output(s, shell=True, stderr=stderr, stdin=stdin)
                log.info("Output: \n" + output);
            else:
                subprocess.check_call(s, shell=True, stderr=stderr, stdout=stdout, stdin=stdin)
                output = None
                
        except subprocess.CalledProcessError as e:
            log.info("Command failed  ({}): {}".format(s,e))
            output = ""
            raise e
    return output


class new_design(Command):
    description="Create a new gadgetron design."
    help="Create a new gadgetron design."
    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--name",
                            required=True,
                            dest='name',
                            help="github username")
        parser.add_argument("--nvsl",
                            required=False,
                            default=False,
                            action='store_true',
                            dest='in_nvsl',
                            help="Create it under the NVSL organization")

    @classmethod
    def go(cls, workspace,args):
        template = workspace.variables["design_template"];
        tail = os.path.basename(template)
        if os.path.exists(tail+".git"):
            log.error("Directory exists: {}".format(tail+".git"))
            sys.exit(1)

        if args.in_nvsl:
            output = do_cmd("""curl -s -u {} https://api.github.com/orgs/NVSL/repos -d '{{"name":"{}"}}'""".
                            format(workspace.variables["github_user"], args.name),
                            stdout="RETURN_VALUE")
        else:
            output = do_cmd("""curl -s -u {} https://api.github.com/user/repos -d '{{"name":"{}"}}'""".
                            format(workspace.variables["github_user"], args.name),
                            stdout="RETURN_VALUE")

        if not dry_run:
            response=json.loads(output)
            if response.get("errors") is not None:
                log.error("Couldn't create new repo: {}.".format(response["errors"][0]["message"]))
                sys.exit(1)
            new_repo = response["ssh_url"]
        else:
            new_repo = "NEW_REPO"
            
        do_cmd(workspace.eval_with_variables(("git clone --bare {template_repo} && " +
                                             "cd {tail}.git && "+ 
                                             "git push --mirror {new_repo}").format(tail=tail,template_repo=template, new_repo=new_repo)))
        do_cmd(workspace.eval_with_variables("rm -rf {tail}.git".format(tail=tail)))

        if not dry_run:
            workspace.add_repo(Repo({
                "directory":"Gadgets/Designs",
                "url" : new_repo,
                "order": 1000
            }))
            workspace.write_config()
        
class update_system(Command):
    description="Update system-wide packagess that Gadgetron depends on"
    help="Update system for Gadgetron"
    @classmethod
    def go(cls, workspace, args):
        do_cmd("update_system.sh")

class setup_devel(Command):
    description="Setup the development environment."
    help="Setup the devel environment.  You should only need to do this once."
    
    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--nvsl-user", required=False, dest='nvsl_user', help="NVSL username")
        parser.add_argument("--github-user", required=False, dest='github_user', help="github username")

    @classmethod
    def go(cls, workspace, args):
        do_cmd("setup_gadgetron.sh {} {}".format(args.nvsl_user, args.github_user))

class DirectoryCommand(Command):
    @classmethod
    def add_args(cls, parser):
        parser.add_argument("directories", nargs="*", help="Directories to operate on (default: all of them)")
    @classmethod
    def go(cls, workspace, args):
        workspace.expand_variables()
        if len(args.directories) == 0:
            repo_list = workspace.repos()
        else:
            repo_list = []
            for d in args.directories:
                r = workspace.get_repo(d)
                if r is None:
                    log.error("Couldn't find repo/directory in workspace config: '{}'.".format(d))
                    sys.exit(1)
                else:
                    repo_list.append(r)

        for repo in repo_list:
            cls.directory_op(repo, workspace, args)
        
class update(DirectoryCommand):
    description="Update all the devel directories"
    help="Get latest updates"
    
    @classmethod
    def directory_op(cls, repo, workspace, args):
        if not dry_run:
            preamble = "Update {}: ".format(repo.full_directory)
            log.info(preamble);
            sys.stderr.write(preamble)
            postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
        try:
            if dry_run:
                print "Create directory {}, if needed.".format(repo.container_directory)
            else:
                try:
                    log.info("Making directory {}".format(repo.container_directory))
                    os.makedirs(os.path.join(workspace.devel_root, repo.container_directory))
                except OSError as e:
                    if not os.path.isdir(os.path.join(workspace.devel_root, repo.container_directory)):
                        log.error("Couldn't make directory {}.".format(repo.container_directory))
                        raise

            if not dry_run:
                log_file = open(os.path.join(workspace.devel_root,
                                             repo.container_directory,
                                             repo.repo_directory + "-update.log"), "w")
            else:
                log_file = None;  # need something to pass to do_cmd
                
            protocol = "SVN" if re.search("^svn", repo.url) is not None else "GIT"
            if os.path.isdir(os.path.join(workspace.devel_root, repo.full_directory)):
                log.info("Directory exists...updating")
                if protocol is "SVN":
                    do_cmd("(cd {} && svn update)".format(os.path.join(workspace.devel_root,
                                                                     repo.full_directory)),
                           stdout=log_file,
                           stderr=log_file)
                else:
                    do_cmd("(cd {} && git pull)".format(os.path.join(workspace.devel_root,
                                                                   repo.full_directory)),
                           stdout=log_file,
                           stderr=log_file)
            else:
                log.info("Directory doesn't exist...checking out")
                if protocol is "SVN":
                    do_cmd("(cd {} && svn co {} && test -d {})".format(os.path.join(workspace.devel_root,
                                                                                    repo.container_directory),
                                                                       repo.url,
                                                                       repo.repo_directory),
                           stdout=log_file,
                           stderr=log_file)
                else:
                    do_cmd("(cd {} && git clone {} && test -d {} )".format(os.path.join(workspace.devel_root,
                                                                                        repo.container_directory),
                                                                           repo.url,
                                                                           repo.repo_directory),
                           stdout=log_file,
                           stderr=log_file)
            if not dry_run:
                log.info("** PASSED **")
                sys.stderr.write(postamble_format.format("", in_green("PASSED")))
                log_file.close();
                do_cmd("mv {} {}".format(os.path.join(workspace.devel_root,
                                                      repo.container_directory,
                                                      repo.repo_directory + "-update.log"),
                                         os.path.join(workspace.devel_root,
                                                      repo.container_directory,
                                                      repo.repo_directory, "update.log")))
        except Exception as e:
            log.info("Update failed.")
            if not dry_run:
                sys.stderr.write(postamble_format.format("", in_red("FAILED")))
                log_file.write(str(e))
            else:
                log.exception(e)
            

                
            
class update_and_build(Command):
    description="Update all the devel directories, then build them"
    help="Get latest updates and build"
    
    @classmethod
    def go(cls, workspace, args):
        update.go(workspace,args)
        build.go(workspace,args)                
            
class build(DirectoryCommand):
    description="Run build in all the devel directories"
    help="Build everything"
    
    @classmethod
    def directory_op(cls, repo, workspace, args):
        if not dry_run:
            preamble = "Build {}: ".format(repo.full_directory)
            log.info(preamble)
            sys.stderr.write(preamble)
            postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
            
        try:
            if (repo.no_build is False and
                (os.path.exists(os.path.join(workspace.devel_root,
                                             repo.full_directory,
                                             "makefile")) or
                 os.path.exists(os.path.join(workspace.devel_root,
                                             repo.full_directory,
                                             "Makefile")))):
                log.info("Building in {}".format(repo.full_directory))
                log_file = open(os.path.join(workspace.devel_root,
                                             repo.full_directory,
                                             "build.log"), "w")
                do_cmd("(cd {} && make clean)".format(os.path.join(workspace.devel_root,
                                                                 repo.full_directory)),
                       stdout=log_file,
                       stderr=log_file)
                do_cmd("(cd {} && make )".format(os.path.join(workspace.devel_root,
                                                            repo.full_directory)),
                       stdout=log_file,
                       stderr=log_file)
                if not dry_run:
                    log.info("** PASSED **")
                    sys.stderr.write(postamble_format.format("", in_green("PASSED")))
            else:
                if not dry_run:
                    log.info("** NO BUILD **")
                    sys.stderr.write(postamble_format.format("", in_green("NO BUILD")))

        except Exception as e:
            log.info("Build failed.")
            if not dry_run:
                sys.stderr.write(postamble_format.format("", in_red("FAILED")))
            log_file.write(str(e))

class make(DirectoryCommand):
    description="Run arbitrary 'make' command in each repo"
    help="Run make everywhere"

    @classmethod
    def add_args(cls, parser):
        DirectoryCommand.add_args(parser)
        parser.add_argument("--args", nargs="+",  dest='make_args', default=[], help="Arguments for 'make'")

    @classmethod
    def directory_op(cls, repo, workspace, args):
        make_cmd= "make {}".format(" ".join(map(pipes.quote, args.make_args))).strip()
        if not dry_run:
            preamble = "'{}' in {}: ".format(make_cmd, repo.full_directory)
            log.info(premable)
            sys.stderr.write(preamble)
            postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
        try:
            if (os.path.exists(os.path.join(repo.full_directory, "makefile")) or
                os.path.exists(os.path.join(repo.full_directory, "Makefile"))):
                log_file = open(os.path.join(workspace.devel_root,
                                             repo.full_directory,
                                             "make.log"), "w")
                do_cmd("(cd {} && {})".format(repo.full_directory, make_cmd),
                       stdout=log_file,
                       stderr=log_file)
                if not dry_run:
                    log.info("** SUCCESS **")
                    sys.stderr.write(postamble_format.format("", in_green("SUCCESS")))
            else:
                if not dry_run:
                    log.info("** NO MAKEFILE **")
                    sys.stderr.write(postamble_format.format("", in_green("NO MAKEFILE")))
        except Exception as e:
            if not dry_run:
                log.info("** FAILURE **")
                sys.stderr.write(postamble_format.format("", in_red("FAILURE")))
            log_file.write(str(e))

class list_repos(Command):
    description="List repositories that are part of this workspace"
    help="List repositories"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--eval",
                            required=False,
                            action='store_true',
                            default=False,
                            help="Expand variables")

    @classmethod
    def go(cls, workspace, args):
        if args.eval:
            workspace.expand_variables()
        for repo in workspace.repos():
            print "{}: {}".format(repo.full_directory, repo.url)
                

class config_lint(Command):
    description="Parse and writout workspace.json"
    help="Check config syntax"
    @classmethod
    def go(cls, workspace, args):
        pass

class config_set(Command):
    description="Set variable value in config file"
    help="Set variable in config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("kv", nargs=2, metavar=("variable", "value"), help="Set <variable>=<value>")
        
    @classmethod
    def go(cls, workspace, args):
        workspace.variables[args.kv[0]] = args.kv[1]
        workspace.write_config()

class add_repo(Command):
    description="Add a repository to checkout as part of this workspace"
    help="Add a repository"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--repo", required=True, dest="repo", help="Repository URL")
        parser.add_argument("--directory", required=True, dest="directory", help="Directory where the repo should live")
        
    @classmethod
    def go(cls, workspace, args):
        workspace.add_repo(Repo({"url": args.repo, "directory":args.directory}))
        workspace.write_config()

class remove_repo(Command):
    description="Remove a repository to checkout as part of this workspace"
    help="Remove a repository"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--directory", required=True, dest="directory", help="Directory holds the contents of the repo")
        
    @classmethod
    def go(cls, workspace, args):
        found = False
        if workspace.get_repo(args.directory) is not None:
            workspace.remove_repo(args.directory)
        else:
            log.error("Couldn't find repo that lives in {}.".format(args.directory))
            sys.exit(1)
        workspace.write_config()

class config_unset(Command):
    description="Remove variable from config file"
    help="Remove variable from config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("k", metavar="variable", help="Variable to remove")
        
    @classmethod
    def go(cls, workspace, args):
        if args.k in workspace.variables:
            del workspace.variables[args.k]
        workspace.write_config()

class config_cleanup(Command):
    description="Reformat config file"
    help="Reformat config file"
    @classmethod
    def go(cls, workspace, args):
        shutil.copyfile(workspace.config_file, workspace.config_file + ".bak")
        json.dump(workspace.to_json(), sys.stdout,
                       sort_keys=True,
                       indent=4,
                       separators=(',', ': '))
        workspace.expand_variables()
        json.dump(workspace.to_json(), sys.stdout,
                  sort_keys=True,
                  indent=4,
                  separators=(',', ': '))

class config_dump(Command):
    description="Parse, re-serialize, and print config file"
    help="Print config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--expand", required=False,  default=False, action="store_true", dest="expand", help="Expand all variables")

    @classmethod
    def go(cls, workspace, args):
        if args.expand:
            workspace.expand_variables()
        json.dump(workspace.to_json(), sys.stdout,
                  sort_keys=True,
                  indent=4,
                  separators=(', ', ' : '))

class diff(DirectoryCommand):
    description="""Run 'diff' an all the repos.  SVN and git both have a 'diff' command but they behave slightly differently.  This command concatenates all the outputs, and adds heading for each repo, so the output is not a legal patch."""
    help="Run diff of each repo."
    @classmethod
    def directory_op(cls, repo, workspace, args):
        sys.stdout.write("{:=^80}\n".format(repo.full_directory))
        sys.stdout.flush()
        protocol = "SVN" if re.search("^svn", repo.url) is not None else "GIT"
        if protocol is "SVN":
            do_cmd("(cd {}; svn diff)".format(os.path.join(workspace.devel_root, repo.full_directory)))
        else:
            do_cmd("(cd {}; git --no-pager diff)".format(os.path.join(workspace.devel_root, repo.full_directory)))

class status(DirectoryCommand):
    description="Run status command on all the repos.  'status' gives slightly different information for SVN and git, so you'll need to make sense of that."
    help="Run 'status' on each repo"
    @classmethod
    def directory_op(cls, repo, workspace, args):
        sys.stdout.write("{:=^80}\n".format(repo.full_directory))
        sys.stdout.flush()
        protocol = "SVN" if re.search("^svn", repo.url) is not None else "GIT"
        if protocol is "SVN":
            do_cmd("(cd {}; svn status)".format(os.path.join(workspace.devel_root, repo.full_directory)))
        else:
            do_cmd("(cd {}; git status)".format(os.path.join(workspace.devel_root, repo.full_directory)))
    
class sanity_check(Command):
    description="Run a sanity check on the environment"
    help="Run sanity check"
    @classmethod
    def go(cls, workspace, args):
        pass # it's a noop, becaue we always run a sanity check.


def sanity(workspace):

    #workspace.expand_variables()
    if os.environ.get("GADGETRON_ROOT") is None:
        log.warn("$GADGETRON_ROOT is not set.")
        return False;
    if os.path.dirname(os.environ.get("GADGETRON_ROOT")) != workspace.devel_root:
        log.warn("$GADGETRON_ROOT ({}) doesn't correspond to this workspace's root ({}).".format(os.environ["GADGETRON_ROOT"], workspace.devel_root))
        return False
    if os.path.dirname(sys.executable) != os.path.join(workspace.devel_root, "repo","venv","Gadgetron","bin"):
        #log.warn(os.path.dirname(sys.executable))
        #log.warn(os.path.join(workspace.devel_root, "repo","venv","Gadgetron","bin"))
        log.warn("Python executable ({}) is not in workspace virtual environment ({})".format(sys.executable,
                                                                                              os.path.join(workspace.devel_root,
                                                                                                           "repo",
                                                                                                           "venv",
                                                                                                           "Gadgetron")))
        return False
    return True;
    
def main(argv):

    panda = ParseAndDispatch("Workspace manager for Gadgetron",
                             "Available commands",
                             "You can call these")
    panda.parser.add_argument("-n", dest='dry_run', default=False, action='store_true', help="Just print what would be done")

    dev_root = os.path.normpath(os.path.join(os.path.dirname(os.path.normpath(__file__)),"..",".."))
    config = os.path.join(dev_root,"repo","config","workspace.json")

    panda.parser.add_argument("--root",
                              dest='devel_root',
                              default=dev_root,
                              help="Workspace root.  Default: {}".format(dev_root))

    panda.parser.add_argument("--config",
                              dest='config_file',
                              default=config,
                              help="Configuration file to use.  Default: {}".format(config))
    panda.parser.add_argument("--force",
                              dest='force',
                              default=False,
                              action="store_true",
                              help="Perform actions even if your configuration seems strange")
    panda.parser.add_argument("--dump-after",
                              dest='dump',
                              default=False,
                              action="store_true",
                              help="Dump the contents of the config file after completing the command")

    panda.parser.add_argument("-v",
                              required=False,
                              action='store_true',
                              default=False,
                              dest='verbose',
                              help="Be verbose")
    
    panda.add_command(update)
    panda.add_command(build)
    panda.add_command(update_and_build)
    panda.add_command(diff)
    panda.add_command(status)
    panda.add_command(make)
    panda.add_command(add_repo)
    panda.add_command(remove_repo)
    panda.add_command(new_design)
    panda.add_command(sanity_check)

    panda.add_command(update_system)
    panda.add_command(setup_devel)
    panda.add_command(list_repos)
    panda.add_command(config_lint)
    panda.add_command(config_cleanup)
    panda.add_command(config_set)
    panda.add_command(config_unset)
    panda.add_command(config_dump)

    args = panda.parse_args(argv[1:])

    if args.verbose:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.INFO)#DEBUG)
        log.info("Verbose output.")
    else:
        log.basicConfig(format="%(levelname)s: %(message)s")


    global dry_run;
    dry_run = args.dry_run;

    workspace = WorkspaceConfig(args.devel_root, args.config_file)
    if not sanity(workspace):
        if args.force:
            log.warning("Continuing despite misconfiguration")
        else:
            log.error("Quiting, due to misconfiguration")
            sys.exit(1);
    
            #os.chdir(workspace.devel_root);
    args.func(workspace, args)
    if args.dump:
        workspace.dump()

if __name__ == "__main__":
    main(sys.argv)
