#!/usr/bin/env python

import argparse
import sys
import subprocess
import os
import re
import json
import pipes
import shutil

class TermColors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def in_red(s):
    return TermColors.FAIL + s + TermColors.ENDC
def in_green(s):
    return TermColors.GREEN + s + TermColors.ENDC

class Repo:
    def __init__(self, json):
        self.url = json["url"]
        self.container_directory = json["directory"]
        self.repo_directory = re.search(".*/(\w*)(/$)?", self.url).group(1)
        self.full_directory = os.path.join(self.container_directory,self.repo_directory)
        self.protocol = "SVN" if re.search("^svn", self.url) is not None else "GIT"

    def to_json(self):
        return {"url": self.url,
                "directory": self.container_directory}

    def expand_variables(self, workspace):
        self.url = full_replace(self.url, variables)
        self.container_directory = workspace.eval_with_variables(self.container_directory)
        self.repo_directory = workspace.eval_with_variables(self.repo_directory)
        self.full_directory = workspace.eval_with_variables(self.full_directory)
        
class WorkspaceConfig:
    def __init__(self,devel_root, config_file):
        json_data = json.load(open(config_file))
        self.config_file = config_file
        self.devel_root = devel_root
        
        self.variables = json_data["vars"]
        self.repos = map(lambda x : Repo(x), json_data["repos"])

    def to_json(self):
        return {"vars" : self.variables,
                "repos" : [r.to_json() for r in self.repos]}

    def expand_variables(self):
        for v in self.variables:
            self.variables[v] = self.eval_with_variables(self.variables[v], self.variables)
        for r in self.repos:
            r.expand_variables(self.variables)

    def write_config_to_file(self, file):
        json.dump(self.to_json(),
                  file,
                  sort_keys=True,
                  indent=4,
                  separators=(',', ': '))        

    def dump(self):
        self.write_config_to_file(sys.stdout)
        
    def write_config(self):
        shutil.copyfile(self.config_file, self.config_file + ".bak")
        self.write_config_to_file(open(self.config_file, "w"))

    def eval_with_variables(self, s):
        from string import Template
        last = ""
        new = s
        while last != new:
            last = new;
            new = Template(last).safe_substitute(vars)
        return new


        
class Command:
    @classmethod
    def setup(cls, subparsers, name, help, description):
        subparser = subparsers.add_parser(name, help=help, description=description)
        subparser.set_defaults(func=cls.go)
        cls.add_args(subparser)
    @classmethod
    def add_args(cls, parser):
        pass

class ParseAndDispatch:
    def __init__(self, app_desc, subp_title, subp_desc):
        self.parser = argparse.ArgumentParser(description=app_desc)
        self.subparsers = self.parser.add_subparsers(title=subp_title,
                                                     description=subp_desc)
    def add_command(self, cmd):
        cmd.setup(self.subparsers, cmd.__name__, cmd.help, cmd.description)

    def parse_args(self, argv):
        return self.parser.parse_args(argv)


dry_run = False;

def do_cmd(s, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin):
    if dry_run is True:
        print s
    else:
        subprocess.check_call(s, shell=True, stderr=stderr, stdout=stdout, stdin=stdin)


class update_system(Command):
    description="Update system-wide packagess that Gadgetron depends on"
    help="Update system for Gadgetron"
    @classmethod
    def go(cls, workspace, args):
        do_cmd("update_system.sh")

class setup_devel(Command):
    description="Setup the development environment."
    help="Setup the devel environment.  You should only need to do this once."
    
    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--user", required=False, dest='user', default=os.environ["USER"], help="NVSL username")

    @classmethod
    def go(cls, workspace, args):
        do_cmd("setup_gadgetron.sh {}".format(args.user))

class update(Command):
    description="Update all the devel directories"
    help="Get latest updates"
    
    @classmethod
    def go(cls, workspace, args):
        workspace.expand_variables()
        for repo in workspace.repos:

            if not dry_run:
                preamble = "Update {}: ".format(repo.full_directory)
                sys.stderr.write(preamble)
                postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
            try:
                log = open(os.path.join(repo.full_directory, "update.log"), "w")
                if dry_run:
                    print "Create directory {}, if needed.".format(repo.container_directory)
                else:
                    try: 
                        os.makedirs(repo.container_directory)
                    except OSError:
                        if not os.path.isdir(repo.container_directory):
                            raise

                if os.path.isdir(repo.full_directory):
                    if repo.protocol is "SVN":
                        do_cmd("(cd {}; svn update)".format(repo.full_directory), stdout=log, stderr=log)
                    else:
                        do_cmd("(cd {}; git pull)".format(repo.full_directory), stdout=log, stderr=log)
                else:
                    if repo.protocol is "SVN":
                        do_cmd("(cd {}; svn co {})".format(repo.full_directory, repo.url), stdout=log, stderr=log)
                    else:
                        do_cmd("(cd {}; git clone {})".format(repo.full_directory, repo.url), stdout=log, stderr=log)
                if not dry_run:
                    sys.stderr.write(postamble_format.format("", in_green("PASSED")))
            except Exception as e:
                if not dry_run:
                    sys.stderr.write(postamble_format.format("", in_red("FAILED")))
                
            
class update_and_build(Command):
    description="Update all the devel directories, then build them"
    help="Get latest updates and build"
    
    @classmethod
    def go(cls, workspace, args):
        update.go(workspace,args)
        build.go(workspace,args)                
            
class build(Command):
    description="Run build in all the devel directories"
    help="Build everything"
    
    @classmethod
    def go(cls, workspace, args):
        #do_cmd("update_gadgetron.sh build")
        workspace.expand_variables()
        for repo in workspace.repos:

            if not dry_run:
                preamble = "Build {}: ".format(repo.full_directory)
                sys.stderr.write(preamble)
                postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
            try:
                if (os.path.exists(os.path.join(repo.full_directory, "makefile")) or
                    os.path.exists(os.path.join(repo.full_directory, "Makefile"))):
                    #print "Building in {}".format(repo.full_directory)
                    log = open(os.path.join(repo.full_directory, "build.log"), "w")
                    do_cmd("(cd {}; make clean)".format(repo.full_directory), stdout=log, stderr=log)
                    do_cmd("(cd {}; make )".format(repo.full_directory), stdout=log, stderr=log)
                    if not dry_run:
                        sys.stderr.write(postamble_format.format("", in_green("PASSED")))
                else:
                    if not dry_run:
                        sys.stderr.write(postamble_format.format("", in_green("NO BUILD")))
            except Exception as e:
                if not dry_run:
                    sys.stderr.write(postamble_format.format("", in_red("FAILED")))

class make(Command):
    description="Run arbitrary 'make' command in each repo"
    help="Run make everywhere"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("make_args", nargs="*",  default=[], help="Arguments for 'make'")

    @classmethod
    def go(cls, workspace, args):
        #do_cmd("update_gadgetron.sh build")
        workspace.expand_variables()
        for repo in workspace.repos:
            
            make_cmd= "make {}".format(" ".join(map(pipes.quote, args.make_args))).strip()
            if not dry_run:
                preamble = "'{}' in {}: ".format(make_cmd, repo.full_directory)
                sys.stderr.write(preamble)
                postamble_format = "{:>" + str(60 - len(preamble)) + "}[{}]\n"
            try:
                if (os.path.exists(os.path.join(repo.full_directory, "makefile")) or
                    os.path.exists(os.path.join(repo.full_directory, "Makefile"))):
                    log = open(os.path.join(repo.full_directory, "make.log"), "w")
                    do_cmd("(cd {}; {})".format(repo.full_directory, make_cmd), stdout=log, stderr=log)
                    if not dry_run:
                        sys.stderr.write(postamble_format.format("", in_green("SUCCESS")))
                else:
                    if not dry_run:
                        sys.stderr.write(postamble_format.format("", in_green("NO MAKEFILE")))
            except Exception as e:
                if not dry_run:
                    sys.stderr.write(postamble_format.format("", in_red("FAILURE")))


class list_repos(Command):
    description="List repositories that are part of this workspace"
    help="List repositories"

    @classmethod
    def go(cls, workspace, args):
        for repo in workspace.repos:
            print "{}: {}".format(repo.full_directory, repo.url)

class config_lint(Command):
    description="Parse and writout workspace.json"
    help="Check config syntax"
    @classmethod
    def go(cls, workspace, args):
        pass

class config_set(Command):
    description="Set variable value in config file"
    help="Set variable in config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("kv", nargs=2, metavar=("variable", "value"), help="Set <variable>=<value>")
        
    @classmethod
    def go(cls, workspace, args):
        workspace.variables[args.kv[0]] = args.kv[1]
        workspace.write_config()

class add_repo(Command):
    description="Add a repository to checkout as part of this workspace"
    help="Add a repository"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--repo", required=True, dest="repo", help="Repository URL")
        parser.add_argument("--directory", required=True, dest="directory", help="Directory where the repo should live")
        
    @classmethod
    def go(cls, workspace, args):
        workspace.repos.append(Repo({"url": args.repo, "directory":args.directory}))
        workspace.write_config()

class remove_repo(Command):
    description="Remove a repository to checkout as part of this workspace"
    help="Remove a repository"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--directory", required=True, dest="directory", help="Directory holds the contents of the repo")
        
    @classmethod
    def go(cls, workspace, args):
        found = False
        for i in range(0, len(workspace.repos)):
            if workspace.eval_with_variables(workspace.repos[i].full_directory) == args.directory:
                del workspace.repos[i]
                found = True
                break;
        if not found:
            print "Couldn't find repo that lives in {}.".format(args.directory)
            sys.exit(1)
        workspace.write_config()

class config_unset(Command):
    description="Remove variable from config file"
    help="Remove variable from config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("k", metavar="variable", help="Variable to remove")
        
    @classmethod
    def go(cls, workspace, args):
        if args.k in workspace.variables:
            del workspace.variables[args.k]
        workspace.write_config()

class config_cleanup(Command):
    description="Reformat config file"
    help="Reformat config file"
    @classmethod
    def go(cls, workspace, args):
        shutil.copyfile(workspace.config_file, workspace.config_file + ".bak")
        json.dump(workspace.to_json(), sys.stdout,#open(workspace.config_file, "w"))
                       sort_keys=True,
                       indent=4,
                       separators=(',', ': '))
        workspace.expand_variables()
        json.dump(workspace.to_json(), sys.stdout,#open(workspace.config_file, "w"))
                  sort_keys=True,
                  indent=4,
                  separators=(',', ': '))

class config_dump(Command):
    description="Parse, re-serialize, and print config file"
    help="Print config file"

    @classmethod
    def add_args(cls, parser):
        parser.add_argument("--expand", required=False,  default=False, action="store_true", dest="expand", help="Expand all variables")

    @classmethod
    def go(cls, workspace, args):
        if args.expand:
            workspace.expand_variables()
        json.dump(workspace.to_json(), sys.stdout,
                  sort_keys=True,
                  indent=4,
                  separators=(', ', ' : '))

class diff(Command):
    description="""Run 'diff' an all the repos.  SVN and git both have a 'diff' command but they behave slightly differently.  This command concatenates all the outputs, and adds heading for each repo, so the output is not a legal patch."""
    help="Run diff of each repo."
    @classmethod
    def go(cls, workspace, args):
        workspace.expand_variables()
        for repo in workspace.repos:
            sys.stdout.write("{:=^80}\n".format(repo.full_directory))
            sys.stdout.flush()
            if repo.protocol is "SVN":
                do_cmd("(cd {}; svn diff)".format(repo.full_directory))
            else:
                do_cmd("(cd {}; git --no-pager diff)".format(repo.full_directory))
                
class status(Command):
    description="Run status command on all the repos.  'status' gives slightly different information for SVN and git, so you'll need to make sense of that."
    help="Run 'status' on each repo"
    @classmethod
    def go(cls, workspace, args):
        workspace.expand_variables()
        for repo in workspace.repos:
            sys.stdout.write("{:=^80}\n".format(repo.full_directory))
            sys.stdout.flush()
            if repo.protocol is "SVN":
                do_cmd("(cd {}; svn status)".format(repo.full_directory))
            else:
                do_cmd("(cd {}; git status)".format(repo.full_directory))

class sanity_check(Command):
    description="Run a sanity check on the environment"
    help="Run sanity check"
    @classmethod
    def go(cls, workspace, args):
        pass # it's a noop, becaue we always run a sanity check.


def sanity(workspace):

    #workspace.expand_variables()
    if os.environ.get("GADGETRON_ROOT") is None:
        print "$GADGETRON_ROOT is not set."
        return False;
    if os.path.dirname(os.environ.get("GADGETRON_ROOT")) != workspace.devel_root:
        print "$GADGETRON_ROOT ({}) doesn't correspond to this workspace's root ({}).".format(os.environ["GADGETRON_ROOT"], workspace.devel_root)
        return False
    if os.path.dirname(sys.executable) != os.path.join(workspace.devel_root, "repo","venv","Gadgetron","bin"):
        print os.path.dirname(sys.executable)
        print os.path.join(workspace.devel_root, "repo","venv","Gadgetron","bin")
        print "Python executable ({}) is not in workspace virtual environment ({})".format(sys.executable, os.path.join(workspace.devel_root, "repo","venv","Gadgetron"))
        return False
    return True;
    
def main(argv):

    panda = ParseAndDispatch("Workspace manager for Gadgetron",
                             "Available commands",
                             "You can call these")
    panda.parser.add_argument("-n", dest='dry_run', default=False, action='store_true', help="Just print what would be done")

    dev_root = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(__file__)),"..",".."))
    panda.parser.add_argument("--root",
                              dest='devel_root',
                              default=dev_root,
                              help="Workspace root.  Default: {}".format(dev_root))
    config = os.path.join(dev_root,"repo","config","workspace.json")

    panda.parser.add_argument("--config", dest='config_file', default=config, help="Configuration file to use.  Default: {}".format(config))
    panda.parser.add_argument("--force", dest='force', default=False, action="store_true", help="Perform actions even if your configuration seems strange")
    panda.parser.add_argument("--dump-after", dest='dump', default=False, action="store_true", help="Dump the contents of the config file after completing the command")
    
    panda.add_command(update)
    panda.add_command(build)
    panda.add_command(update_and_build)
    panda.add_command(diff)
    panda.add_command(status)
    panda.add_command(make)
    panda.add_command(add_repo)
    panda.add_command(remove_repo)
    panda.add_command(sanity_check)

    panda.add_command(update_system)
    panda.add_command(setup_devel)
    panda.add_command(list_repos)
    panda.add_command(config_lint)
    panda.add_command(config_cleanup)
    panda.add_command(config_set)
    panda.add_command(config_unset)
    panda.add_command(config_dump)
    
    args = panda.parse_args(argv[1:])
    global dry_run;
    dry_run = args.dry_run;

    workspace = WorkspaceConfig(args.devel_root, args.config_file)
    if not sanity(workspace):
        if args.force:
            print "Continuing despite misconfiguration"
        else:
            print "Quiting, due to misconfiguration"
            sys.exit(1);
            
    os.chdir(workspace.devel_root);
    args.func(workspace, args)
    if args.dump:
        workspace.dump()
if __name__ == "__main__":
    main(sys.argv)
